# First Trial
한 명의 학생이 여러 종목의 점수가 높아도 동시에 점수에 기여할 수 없고, greedy search 로도 풀 수가 없기 떄문에 완전탐색으로 접근

DFS로 각 과목의 index와 이미 참여한 학생들의 set을 parameter로 하여, 각 호출마다, 참여 가능한 모든 학생이 해당 과목에 기여하는 모든 케이스 순회

따라서 시간복잡도는 O(N!) 이 된다.

# Second Trial
위의 아주 큰 시간복잡도를 줄이는 방법은 DP이다.

subproblem을 선택한 학생들이 점수에 기여했을 때의 점수로 가정한다면, key를 선택한 학생들을 나타내는 tuple (or bitmask), value를 선택한 학생들이 낼 수 있는 최대 점수로 갖는 dictionary로 subproblem을 저장할 수 있다.

이 때 해당 학생들이 어느 종목에 기여했는지 확실하지 않아 모호하다고 생각할 수 있지만, tuple이 가지고 있는 학생의 수가 대응하는 과목들을 표현하기 때문에 과목을 중복하여 계산하는 일은 없다.

예를 들어 "01256" tuple이라면 0,1,2,3,4 과목에서 0,1,2,5,6 학생들이 얻을 수 있는 최고 점수가 된다.

이 방법으로 해결하게 된다면 tuple의 후보는 학생들이 포함/미포함 경우 뿐이므로 2^N이 될 것이고, 따라서 시간복잡도는 O(2^N) 으로 줄어든다.